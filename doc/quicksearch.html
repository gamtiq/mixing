<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" mixing Modules mixing Source: index.js /** * @module mixing */ /*jshint latedef:nofunc*/ var defaultSettings; if (! Array.isArray) { Array.isArray = function(obj) { return Object.prototype.toString.call(obj) === \"[object Array]\"; }; } function prepareFieldList(fieldList, value) { var map, nI, regexp, sType; if (Array.isArray(fieldList)) { if (fieldList.length &gt; 0) { map = {}; nI = fieldList.length; do { map[ fieldList[--nI] ] = value || null; } while(nI); } } else { sType = typeof fieldList; if (sType === \"string\" || sType === \"symbol\") { map = {}; map[fieldList] = value || null; } else if (sType === \"object\") { if (fieldList instanceof RegExp) { regexp = fieldList; } else { map = fieldList; } } } return {map: map, regexp: regexp}; } function copy(destination, source, propName, settings) { /*jshint laxbreak:true*/ var propValue = source[propName], sPropString = propName.toString(), bFuncProp, change, otherNameMap, sType, value; function getParam() { return { field: propName, value: propValue, targetValue: destination[propName], target: destination, source: source }; } if ((! settings.ownProperty || source.hasOwnProperty(propName)) &amp;&amp; (! settings.copyMap || (propName in settings.copyMap)) &amp;&amp; (! settings.copyRegExp || settings.copyRegExp.test(sPropString)) &amp;&amp; (! settings.exceptions || ! settings.exceptions[propName]) &amp;&amp; (! settings.exceptRegExp || ! settings.exceptRegExp.test(sPropString)) &amp;&amp; (! settings.filter || settings.filter.call(null, getParam())) /* jshint -W122 */ &amp;&amp; (! settings.filterRegExp || settings.filterRegExp.test(typeof propValue === \"symbol\" ? propValue.toString() : propValue))) { /* jshint +W122 */ otherNameMap = settings.otherNameMap; if (otherNameMap &amp;&amp; (propName in otherNameMap)) { propName = otherNameMap[propName]; } sType = typeof propValue; // If recursive mode and field's value is an object if (settings.recursive &amp;&amp; propValue &amp;&amp; sType === \"object\" &amp;&amp; (value = destination[propName]) &amp;&amp; typeof value === \"object\" &amp;&amp; (! Array.isArray(propValue) || settings.mixFromArray) &amp;&amp; (! Array.isArray(value) || settings.mixToArray)) { mixing(value, propValue, settings.mixFromArray ? mixing({oneSource: true}, settings) : settings); } else { bFuncProp = (sType === \"function\"); if ((! bFuncProp || settings.copyFunc) &amp;&amp; (! (propName in destination) || ((value = settings.overwrite) &amp;&amp; ( typeof value !== \"function\" || value(getParam()) ) &amp;&amp; ( ! (value instanceof RegExp) || value.test(propName) ) ))) { if (settings.changeFunc) { propValue = settings.changeFunc.call(null, getParam()); } else if ((change = settings.change) &amp;&amp; (propName in change)) { propValue = change[propName]; } if (bFuncProp &amp;&amp; settings.funcToProto) { destination.constructor.prototype[propName] = propValue; } else { destination[propName] = propValue; } } } } } /** * Copy/add all fields and functions from source objects into the target object. * As a result the target object may be modified. * * @param {Object | Function} destination * The target object into which fields and functions will be copied. * @param {Array | Object} source * Array of source objects or just one object whose contents will be copied. * If a source is a falsy value (e.g. `null` or `undefined`), the source will be skipped. * @param {Object} [settings] * Operation settings. Fields are names of settings, their values are the corresponding values of settings. * The following settings are being supported. * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Default value&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`copyFunc`&lt;/td&gt; * &lt;td&gt;`Boolean`&lt;/td&gt; * &lt;td&gt;`true`&lt;/td&gt; * &lt;td&gt;Should functions be copied?&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`funcToProto`&lt;/td&gt; * &lt;td&gt;`Boolean`&lt;/td&gt; * &lt;td&gt;`false`&lt;/td&gt; * &lt;td&gt; * Should functions be copied into `prototype` of the target object's `constructor` * (i.e. into `destination.constructor.prototype`)? * &lt;br&gt; * If `false` then functions will be copied directly into the target object. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`processSymbol`&lt;/td&gt; * &lt;td&gt;`Boolean`&lt;/td&gt; * &lt;td&gt;`true`&lt;/td&gt; * &lt;td&gt;Should symbol property keys (i.e. fields whose name is a symbol) be processed?&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`overwrite`&lt;/td&gt; * &lt;td&gt;`Boolean | Function | RegExp`&lt;/td&gt; * &lt;td&gt;`false`&lt;/td&gt; * &lt;td&gt; * Specifies whether a field/function should be overwritten when it exists in the target object. * &lt;br&gt; * If `true` then any existent field will be overwritten in the target object. * &lt;br&gt; * Function or regular expression can be used to select fields that should be overwritten. * &lt;br&gt; * If a regular expression is passed, only those fields will be overwritten * whose names are matching the regular expression. * &lt;br&gt; * If specified function returns `true` for a field, * the field will be overwritten in the target object. * An object with contextual data is passed into the function (see details below). * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`recursive`&lt;/td&gt; * &lt;td&gt;`Boolean`&lt;/td&gt; * &lt;td&gt;`false`&lt;/td&gt; * &lt;td&gt; * Should this function be called recursively when field's value of the target and source object is an object? * &lt;br&gt; * If `true` then object fields from the target and source objects will be mixed by using this function * with the same settings. * &lt;br&gt; * This option has no dependency with `overwrite` setting and has priority over it. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`mixFromArray`&lt;/td&gt; * &lt;td&gt;`Boolean`&lt;/td&gt; * &lt;td&gt;`false`&lt;/td&gt; * &lt;td&gt; * Should contents of a field of the source object be copied when the field's value is an array? * &lt;br&gt; * Will be used only when `recursive` setting has `true` value. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`mixToArray`&lt;/td&gt; * &lt;td&gt;`Boolean`&lt;/td&gt; * &lt;td&gt;`false`&lt;/td&gt; * &lt;td&gt; * Should contents of a field of the source object be copied into a field of the target object * when the latest field's value is an array? * &lt;br&gt; * Will be used only when `recursive` setting has `true` value. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`mixArray`&lt;/td&gt; * &lt;td&gt;`Boolean`&lt;/td&gt; * &lt;td&gt;`false`&lt;/td&gt; * &lt;td&gt; * Sets default value for `mixFromArray` and `mixToArray` settings. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`oneSource`&lt;/td&gt; * &lt;td&gt;`Boolean`&lt;/td&gt; * &lt;td&gt;`false`&lt;/td&gt; * &lt;td&gt; * Indicates that array that is passed as `source` parameter should be interpreted * directly as copied object instead of list of source objects. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`ownProperty`&lt;/td&gt; * &lt;td&gt;`Boolean`&lt;/td&gt; * &lt;td&gt;`false`&lt;/td&gt; * &lt;td&gt;Should only own properties of the source object be copied in the target object?&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`copy`&lt;/td&gt; * &lt;td&gt;`Array | Object | RegExp | String | Symbol`&lt;/td&gt; * &lt;td&gt;`\"\"` (empty string)&lt;/td&gt; * &lt;td&gt; * Array, object, regular expression or string/symbol that defines names of fields/functions that should be copied. * &lt;br&gt; * If an object is passed then his fields determine copied elements. * If a regular expression is passed, then field names matching the regular expression will be copied. * If a string/symbol is passed then it is name of the only copied field. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`except`&lt;/td&gt; * &lt;td&gt;`Array | Object | RegExp | String | Symbol`&lt;/td&gt; * &lt;td&gt;`\"\"` (empty string)&lt;/td&gt; * &lt;td&gt; * Array, object, regular expression or string/symbol that defines names of fields/functions that shouldn't be copied. * &lt;br&gt; * If an object is passed then his fields with true values determine non-copied elements. * If a regular expression is passed, then field names matching the regular expression will not be copied. * If a string/symbol is passed then it is name of the only non-copied field. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`filter`&lt;/td&gt; * &lt;td&gt;`Function | RegExp`&lt;/td&gt; * &lt;td&gt;`null`&lt;/td&gt; * &lt;td&gt; * Function or regular expression that can be used to select elements that should be copied. * &lt;br&gt; * If regular expression is passed, only those fields will be copied whose values are matching regular expression. * &lt;br&gt; * If specified function returns `true` for a field, * the field will be copied in the target object. * &lt;br&gt; * An object with contextual data is passed into function (see details below). * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`otherName`&lt;/td&gt; * &lt;td&gt;`Object`&lt;/td&gt; * &lt;td&gt;`null`&lt;/td&gt; * &lt;td&gt; * Defines \"renaming table\" for copied elements. * &lt;br&gt; * Fields of the table are names from a source object, values are the corresponding names in the target object. * &lt;br&gt; * For example, the call * &lt;br&gt; * &lt;code&gt; * mixing({}, {field: 1, func: \"no-func\"}, {otherName: {\"field\": \"prop\", \"func\": \"method\"}}) * &lt;/code&gt; * &lt;br&gt; * will return the following object * &lt;br&gt; * `{prop: 1, method: \"no-func\"}` * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;`change`&lt;/td&gt; * &lt;td&gt;`Function | Object`&lt;/td&gt; * &lt;td&gt;`null`&lt;/td&gt; * &lt;td&gt; * Function or object that gives ability to change values that should be copied. * &lt;br&gt; * If an object is passed then his fields determine new values for copied elements. * &lt;br&gt; * If a function is passed then value returned by the function for a field will be copied into the target object * instead of original field's value. * &lt;br&gt; * An object with contextual data is passed into function (see details below). * &lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; * An object having the following fields is passed into `overwrite`, `filter` and `change` function: * &lt;ul&gt; * &lt;li&gt;`field` - field name * &lt;li&gt;`value` - field value from the source object * &lt;li&gt;`targetValue` - field value from the target object * &lt;li&gt;`target` - reference to the target object * &lt;li&gt;`source` - reference to the source object * &lt;/ul&gt; * Default values of settings can be redefined by {@link module:mixing.setSettings setSettings} method. * &lt;br&gt; * `copy`, `except` and `filter` settings can be used together. * In such situation a field will be copied only when the field satisfies to all settings * (i.e. belongs to copied elements, not in exceptions and conforms to filter). * @return {Object} * Modified target object. * @alias module:mixing */ function mixing(destination, source, settings) { /*jshint boss:true, laxbreak:true*/ var destinationType = typeof destination; var sourceType = typeof source; if (destination &amp;&amp; (destinationType === \"object\" || destinationType === \"function\") &amp;&amp; source &amp;&amp; (sourceType === \"object\" || sourceType === \"function\")) { var obj; // Prepare parameters if (typeof settings !== \"object\" || settings === null) { settings = defaultSettings || {}; } else if (defaultSettings) { obj = defaultSettings; defaultSettings = null; settings = mixing({}, [settings, obj]); defaultSettings = obj; } if (! Array.isArray(source) || settings.oneSource) { source = [source]; } // Prepare settings var getOwnPropertySymbols = Object.getOwnPropertySymbols, getPrototypeOf = Object.getPrototypeOf, options = { copyFunc: (\"copyFunc\" in settings ? settings.copyFunc : true), funcToProto: Boolean(settings.funcToProto), processSymbol: (\"processSymbol\" in settings ? settings.processSymbol : true) &amp;&amp; typeof getOwnPropertySymbols === \"function\", mixFromArray: Boolean( (\"mixFromArray\" in settings) ? settings.mixFromArray : settings.mixArray ), mixToArray: Boolean( (\"mixToArray\" in settings) ? settings.mixToArray : settings.mixArray ), overwrite: settings.overwrite, ownProperty: Boolean(settings.ownProperty), recursive: Boolean(settings.recursive), otherNameMap: (\"otherName\" in settings ? settings.otherName : null), changeFunc: settings.changeFunc, copyMap: settings.copyMap, copyRegExp: settings.copyRegExp, exceptions: settings.exceptions, exceptRegExp: settings.exceptRegExp, filterRegExp: settings.filterRegExp }, bOwnProperty = options.ownProperty, bProcessSymbol = options.processSymbol, change = settings.change, copyList = settings.copy, exceptList = settings.except, filter = settings.filter, nI, nK, nL, nQ, propName; if (copyList) { copyList = prepareFieldList(copyList); options.copyMap = copyList.map; options.copyRegExp = copyList.regexp; } if (exceptList) { exceptList = prepareFieldList(exceptList, true); options.exceptions = exceptList.map; options.exceptRegExp = exceptList.regexp; } if (filter) { options[typeof filter === \"object\" ? \"filterRegExp\" : \"filter\"] = filter; } if (change) { options[typeof change === \"function\" ? \"changeFunc\" : \"change\"] = change; } // Copy fields and functions according to settings for (nI = 0, nL = source.length; nI &lt; nL; nI++) { if (obj = source[nI]) { for (propName in obj) { copy(destination, obj, propName, options); } // Process symbol property keys if (bProcessSymbol) { exceptList = {}; do { copyList = getOwnPropertySymbols(obj); for (nK = 0, nQ = copyList.length; nK &lt; nQ; nK++) { propName = copyList[nK]; if (! (propName in exceptList)) { copy(destination, obj, propName, options); exceptList[propName] = true; } } obj = bOwnProperty ? null : getPrototypeOf(obj); } while (obj); } } } } return destination; } /** * Copy values of all of the own properties from one or more source objects to the target object * (similar to `Object.assign`). * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * mixing(destination, Array.prototype.slice.call(arguments, 1), {overwrite: true, ownProperty: true}); * &lt;/pre&gt;&lt;/code&gt; * * @param {Object | Function} destination * The target object into which fields and functions will be copied. * @param {...Object} source * An object whose contents will be copied. * If a source is a falsy value (e.g. `null` or `undefined`), the source will be skipped. * @return {Object} * Modified `target` object. */ mixing.assign = function(destination) { return mixing(destination, Array.prototype.slice.call(arguments, 1), {overwrite: true, ownProperty: true}); }; /** * Change values of fields of given object. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * mixing(source, source, {change: change, overwrite: true, oneSource: true}); * &lt;/pre&gt;&lt;/code&gt; * * @param {Array | Object} source * An array or an object whose fields should be modified. * @param {Function | Object} change * A function or an object that specifies the modification. See {@link module:mixing mixing} for details. * @return {Object} * Modified `source` object. */ mixing.change = function(source, change) { return mixing(source, source, {change: change, overwrite: true, oneSource: true}); }; /** * Make a copy of source object(s). * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * var copy = mixing({}, source, settings); * &lt;/pre&gt;&lt;/code&gt; * * @param {Array | Object} source * Array of source objects or just one object whose contents will be copied. * @param {Object} [settings] * Operation settings. See {@link module:mixing mixing} for details. * @return {Object} * Newly created object containing contents of source objects. */ mixing.copy = function(source, settings) { return mixing({}, source, settings); }; /** * Copy fields from source object(s) into every object item of given array. * * @param {Array} destinationList * An array whose items should be modified. * @param {Array | Object} source * Array of source objects or just one object whose contents will be copied. * @param {Object} [settings] * Operation settings that will be applied to every copying. See {@link module:mixing mixing} for details. * @return {Array} * Original `destinationList` with possibly modified object items. */ mixing.mixToItems = function(destinationList, source, settings) { for (var nI = 0, nL = destinationList.length; nI &lt; nL; nI++) { destinationList[nI] = mixing(destinationList[nI], source, settings); } return destinationList; }; /** * Make a copy of `this` object. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * var copy = mixing({}, this, settings); * &lt;/pre&gt;&lt;/code&gt; * It can be transferred to an object to use as a method. * * @param {Object} [settings] * Operation settings. See {@link module:mixing mixing} for details. * @return {Object} * Newly created object containing contents of `this` object. */ mixing.clone = function(settings) { return mixing({}, this, settings); }; /** * Filter `this` object. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * var result = mixing({}, this, {filter: filter}); * &lt;/pre&gt;&lt;/code&gt; * It can be transferred to an object to use as a method. * * @param {Function | Object} filter * Filter function to select fields or object that represents operation settings including filter function. * See {@link module:mixing mixing} for details. * @return {Object} * Newly created object containing fields of `this` object for which filter function returns true. */ mixing.filter = function(filter) { return mixing({}, this, typeof filter === \"function\" ? {filter: filter} : filter); }; /** * Copy and change values of fields of `this` object. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * var result = mixing({}, this, {change: change}); * &lt;/pre&gt;&lt;/code&gt; * It can be transferred to an object to use as a method. * * @param {Function | Object} change * Function to change values of copied fields or object that represents operation settings including change function. * See {@link module:mixing mixing} for details. * @return {Object} * Newly created object containing fields of `this` object with changed values. */ mixing.map = function(change) { return mixing({}, this, typeof change === \"function\" ? {change: change} : change); }; /** * Copy/add all fields and functions from source objects into `this` object. * As a result `this` object may be modified. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * mixing(this, source, settings); * &lt;/pre&gt;&lt;/code&gt; * It can be transferred to an object to use as a method. * * @param {Array | Object} source * Array of source objects or just one object whose contents will be copied. * @param {Object} [settings] * Operation settings. See {@link module:mixing mixing} for details. * @return {Object} * Modified `this` object. */ mixing.mix = function(source, settings) { return mixing(this, source, settings); }; /** * Change values of fields of `this` object. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * mixing.change(this, change); * &lt;/pre&gt;&lt;/code&gt; * It can be transferred to an object to use as a method. * * @param {Function | Object} change * A function or an object that specifies the modification. See {@link module:mixing mixing} for details. * @return {Object} * Modified `this` object. */ mixing.update = function(change) { return mixing.change(this, change); }; /** * Return default settings that were set earlier. * * @return {Object | undefined} * Default settings that were set earlier or `undefined / null` if default settings were not set. */ mixing.getSettings = function() { return defaultSettings; }; /** * Set (redefine, reset) default settings that should be used for subsequent {@link module:mixing mixing} calls. * * @param {Object | undefined} [settings] * Default settings that should be used for subsequent {@link module:mixing mixing} calls. * Initial default values will be used for settings that are not specified in the passed object. * Pass `undefined`, `null`, non-object or to call without parameter * to reset default settings to initial values. * @alias module:mixing.setSettings */ mixing.setSettings = function(settings) { defaultSettings = typeof settings === \"object\" ? settings : null; }; module.exports = mixing; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" mixing Modules mixing Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" mixing Modules mixing mixing Functions to mix, filter, change and copy/clone objects. Supports processing of symbol property keys that are introduced in ECMAScript 2015. mixing is like an improved version of Object.assign and is compatible with ECMAScript 3+. Features Overwrite all or only some fields, or do not change existent fields (specified by overwrite setting). Mix recursively objects and arrays (use recursive and mixArray settings). Copy only own or all fields of a source object (ownProperty setting). Selectively copy fields from a source object (copy, except and filter settings). Rename fields of a source object that are added into the target object (otherName setting). Change values that are copied into the target object (change setting). Several helpful \"shortcut\" functions that can be used standalone or as methods. const obj = {a: 1, b: {c: \"\", d: false}, e: [{f1: 1, f2: 2}, {f1: 0, f3: 9}], z: true}; ... mixing( obj, {a: 3, b: {c: 1, c2: \"abc\"}, e: [{f2: -3}, {f1: 7, f2: null}, {f1: 10}], x: \"way\"}, {overwrite: true, recursive: true, mixArray: true} ); // obj is {a: 3, b: {c: 1, d: false, c2: \"abc\"}, e: [{f1: 1, f2: -3}, {f1: 7, f3: 9, f2: null}, {f1: 10}], x: \"way\", z: true} Usage Examples API Related projects InstallationNodenpm install mixingRingoringo-admin install gamtiq/mixingBowerbower install mixingAMD, script tagUse dist/mixing.js or dist/mixing.min.js (minified version). Usage ↑Node, Ringovar mixing = require(\"mixing\"); ...AMDdefine([\"path/to/dist/mixing.js\"], function(mixing) { ... });Bower, script tag&lt;!-- Use bower_components/mixing/dist/mixing.js if the library was installed via Bower --&gt; &lt;script type=\"text/javascript\" src=\"path/to/dist/mixing.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // mixing is available via mixing field of window object ... &lt;/script&gt;Examples ↑var copy = mixing.copy(source); // Make a shallow copy of source var result = mixing({a: 1, b: 2}, {c: 3, d: 4}); // result is {a: 1, b: 2, c: 3, d: 4} mixing({a: 1, b: 2}, {a: \"a\", b: {}, c: 3, d: 4}); // Returns {a: 1, b: 2, c: 3, d: 4} mixing({a: 1, b: 2, z: 100}, {a: \"a\", b: {}, c: 3, d: 4}, {overwrite: true}); // Returns {a: \"a\", b: {}, c: 3, d: 4, z: 100} // Overwrite only fields whose names are matching regular expression mixing( {a: 1, b: 2, alfa: \"omega\", delta: \"gamma\", z: 100}, {a: \"a\", b: {c: true}, d: 4, delta: 3, z: false}, {overwrite: /^[a-c]$/} ); // Returns {a: \"a\", alfa: \"omega\", b: {c: true}, d: 4, delta: \"gamma\", z: 100} // Recursive mix mixing( {a: 1, b: {c: \"\", d: false}, e: [{f1: 1, f2: 2}, {f1: 0, f3: 9}], z: true}, {a: 3, b: {c: 1, c2: \"abc\"}, e: [{f2: -3}, {f1: 7, f2: null}, {f1: 10}], x: \"way\"}, {overwrite: true, recursive: true, mixArray: true} ); // Returns {a: 3, b: {c: 1, d: false, c2: \"abc\"}, e: [{f1: 1, f2: -3}, {f1: 7, f3: 9, f2: null}, {f1: 10}], x: \"way\", z: true} mixing({a: 1, b: 2, c: \"\", d: false}, {a: -1, b: null, c: true, d: \"empty\"}, {overwrite: true, except: {a: false, b: true, c: null, d: \"yes\"}}); // Returns {a: -1, b: 2, c: true, d: false} mixing({a: 1, b: 2}, {a3: 3, b: null, c4: \"e5\", d_97: new Date(), c: 3, \"e-2\": \"empty\"}, {except: /\\d/}); // Returns {a: 1, b: 2, c: 3} mixing.copy({a: 1, a2: 2, a3: \"a3\", b: 4, copy5: 5, d: \"delta\", e: \"-123\"}, {except: /a/, filter: /\\W/}); // Returns {e: \"-123\"} mixing({x: 5}, {a: 1, a2: \"2man\", a3: \"a3\", b: 4, copy5: 5, delta: \"plus\", e: 4}, {copy: /a/, filter: /^\\D/}); // Returns {x: 5, a3: \"a3\", delta: \"plus\"} mixing.assign({a: \"start\"}, {a: 1, b: 0}, {b: 2, c: 3, d: 4}, null, {e: \"end\"}); // Returns {a: 1, b: 2, c: 3, d: 4, e: \"end\"} // Change default settings mixing.setSettings({overwrite: true, oneSource: true}); // Mix arrays mixing([1, 2, 3], [\"a\", \"b\", \"c\", \"d\"]); // Returns [\"a\", \"b\", \"c\", \"d\"] mixing([3, 2, 1, 4, 5], [1, 2, 3]); // Returns [1, 2, 3, 4, 5] // Get redefined default settings mixing.getSettings(); // Returns {overwrite: true, oneSource: true} // Reset default settings to initial values mixing.setSettings(); // Filter and change field values mixing({}, [{a: 1, b: 100}, null, {c: 3, d: new Date(), e: 4}, {f: \"str\", g: 50}, undefined, {h: 7}], { except: [\"a\", \"g\"], filter: function(data) { var value = data.value; return typeof value === \"number\" &amp;&amp; value &lt; 10; }, change: function(data) { var value = data.value; return value &gt; 5 ? value * value : value; } }); // Returns {c: 3, e: 4, h: 49} mixing.change({a: 1, b: \"abc\", c: null, d: 4444, e: false}, {b: 22, c: 333, e: 55555}); // Returns {a: 1, b: 22, c: 333, d:4444, e: 55555} // Change items in array mixing.mixToItems([{a: 1, b: 2}, {b: 3}, 83, {}], {a: null, c: 9}); // Returns [{a: 1, b: 2, c: 9}, {a: null, b: 3, c: 9}, 83, {a: null, c: 9}] mixing.mixToItems([null, {a: 1, b: 2}, {b: 3, z: 0}, {}], {a: null, b: false}, {overwrite: true}); // Returns [null, {a: null, b: false}, {a: null, b: false, z: 0}, {a: null, b: false}] // Clone, filter, map, update var obj = { a: 1, b: 2, clone: mixing.clone, filter: mixing.filter, map: mixing.map, update: mixing.update }; obj[Symbol(\"field\")] = Symbol(\"value\"); var obj2 = obj.clone(); // obj2 is a shallow copy of obj (contains symbol property key) function isNumericValue(data) { return typeof data.value === \"number\"; } var obj3 = obj.filter(isNumericValue); // {a: 1, b: 2} var obj4 = obj.map({ filter: isNumericValue, change: function(data) { return data.value + data.value; } }); // {a: 2, b: 4} obj.update(function(data) { var value = data.value; return typeof value === \"number\" ? ++value : value; }); // obj is {a: 2, b: 3, clone: ...}See additional examples in tests. API ↑See doc directory for details. mixing(destination: Object, source: Array | Object, [settings: Object]);Copy/add all fields and functions from source object(s) into the destination object. As a result the destination object may be modified. Several settings are supported (see doc/module-mixing.html for details): copyFunc: Boolean - Should functions be copied? funcToProto: Boolean - Should functions be copied into prototype of the destination object's constructor? processSymbol: Boolean - Should symbol property keys be processed? overwrite: Boolean | Function | RegExp - Specifies whether a field/function should be overwritten when it exists in the target object. recursive: Boolean - Should this function be called recursively when field's value of the destination and source object is an object? mixFromArray: Boolean - Should in recursive mode contents of a field of the source object be copied when the field's value is an array? mixToArray: Boolean - Should in recursive mode contents of a field of the source object be copied into a field of the target object when the latest field's value is an array? mixArray: Boolean - Default value for mixFromArray and mixToArray settings. oneSource: Boolean - Should source array be interpreted directly as copied object instead of list of source objects? ownProperty: Boolean - Should only own properties of the source object be copied into the target object? copy: Array | Object | RegExp | String | Symbol - Array, object, regular expression or string/symbol that defines names of fields/functions that should be copied. except: Array | Object | RegExp | String | Symbol - Array, object, regular expression or string/symbol that defines names of fields/functions that shouldn't be copied. filter: Function | RegExp - Function or regular expression that can be used to select elements that should be copied. otherName: Object - Defines \"renaming table\" for copied elements. change: Function | Object - Function or object that gives ability to change values that should be copied. .assign(destination: Object, ...source: Object);Copy values of all of the own properties from one or more source objects to the target object (similar to Object.assign). .change(source: Array | Object, change: Function | Object);Change values of fields of given object. .copy(source: Array | Object, [settings: Object]);Make a copy of source object(s). .mixToItems(destinationList: Array, source: Array | Object, [settings: Object]);Copy fields from source object(s) into every object item of given array. .clone([settings: Object]);Make a copy of this object. This function can be transferred to an object to use as a method. For example: SomeClass.prototype.clone = mixing.clone; ... var obj = new SomeClass(); ... var copy = obj.clone();.filter(filter: Function | Object);Filter this object. This function can be transferred to an object to use as a method. For example: SomeClass.prototype.filter = mixing.filter; ... var obj = new SomeClass(); ... var result = obj.filter(function(data) { // data.source is obj, data.target is result ... });.map(change: Function | Object);Copy and change values of fields of this object. This function can be transferred to an object to use as a method. For example: SomeClass.prototype.map = mixing.map; ... var obj = new SomeClass(); ... var result = obj.map(function(data) { // data.source is obj, data.target is result ... });.mix(source: Array | Object, [settings: Object]);Copy/add all fields and functions from source objects into this object. As a result this object may be modified. This function can be transferred to an object to use as a method. For example: SomeClass.prototype.mix = mixing.mix; ... var obj = new SomeClass(); ... obj.mix([obj1, obj2]);.update(change: Function | Object);Change values of fields of this object. This function can be transferred to an object to use as a method. For example: SomeClass.prototype.update = mixing.update; ... var obj = new SomeClass(); ... obj.update({a: 2, b: \"\"});.getSettings();Return default settings that were set earlier. .setSettings([settings: Object]);Set (redefine, reset) default settings that should be used for subsequent mixing calls. Related projects ↑ adam basespace extend teo LicenceMIT × Search results Close "},"module-mixing.html":{"id":"module-mixing.html","title":"Module: mixing","body":" mixing Modules mixing Module: mixing (require(\"mixing\"))(destination, source [, settings]) Copy/add all fields and functions from source objects into the target object. As a result the target object may be modified. Parameters: Name Type Argument Description destination Object | function The target object into which fields and functions will be copied. source Array | Object Array of source objects or just one object whose contents will be copied. If a source is a falsy value (e.g. null or undefined), the source will be skipped. settings Object &lt;optional&gt; Operation settings. Fields are names of settings, their values are the corresponding values of settings. The following settings are being supported. NameTypeDefault valueDescription copyFunc Boolean true Should functions be copied? funcToProto Boolean false Should functions be copied into prototype of the target object's constructor (i.e. into destination.constructor.prototype)? If false then functions will be copied directly into the target object. processSymbol Boolean true Should symbol property keys (i.e. fields whose name is a symbol) be processed? overwrite Boolean | Function | RegExp false Specifies whether a field/function should be overwritten when it exists in the target object. If true then any existent field will be overwritten in the target object. Function or regular expression can be used to select fields that should be overwritten. If a regular expression is passed, only those fields will be overwritten whose names are matching the regular expression. If specified function returns true for a field, the field will be overwritten in the target object. An object with contextual data is passed into the function (see details below). recursive Boolean false Should this function be called recursively when field's value of the target and source object is an object? If true then object fields from the target and source objects will be mixed by using this function with the same settings. This option has no dependency with overwrite setting and has priority over it. mixFromArray Boolean false Should contents of a field of the source object be copied when the field's value is an array? Will be used only when recursive setting has true value. mixToArray Boolean false Should contents of a field of the source object be copied into a field of the target object when the latest field's value is an array? Will be used only when recursive setting has true value. mixArray Boolean false Sets default value for mixFromArray and mixToArray settings. oneSource Boolean false Indicates that array that is passed as source parameter should be interpreted directly as copied object instead of list of source objects. ownProperty Boolean false Should only own properties of the source object be copied in the target object? copy Array | Object | RegExp | String | Symbol \"\" (empty string) Array, object, regular expression or string/symbol that defines names of fields/functions that should be copied. If an object is passed then his fields determine copied elements. If a regular expression is passed, then field names matching the regular expression will be copied. If a string/symbol is passed then it is name of the only copied field. except Array | Object | RegExp | String | Symbol \"\" (empty string) Array, object, regular expression or string/symbol that defines names of fields/functions that shouldn't be copied. If an object is passed then his fields with true values determine non-copied elements. If a regular expression is passed, then field names matching the regular expression will not be copied. If a string/symbol is passed then it is name of the only non-copied field. filter Function | RegExp null Function or regular expression that can be used to select elements that should be copied. If regular expression is passed, only those fields will be copied whose values are matching regular expression. If specified function returns true for a field, the field will be copied in the target object. An object with contextual data is passed into function (see details below). otherName Object null Defines \"renaming table\" for copied elements. Fields of the table are names from a source object, values are the corresponding names in the target object. For example, the call mixing({}, {field: 1, func: \"no-func\"}, {otherName: {\"field\": \"prop\", \"func\": \"method\"}}) will return the following object {prop: 1, method: \"no-func\"} change Function | Object null Function or object that gives ability to change values that should be copied. If an object is passed then his fields determine new values for copied elements. If a function is passed then value returned by the function for a field will be copied into the target object instead of original field's value. An object with contextual data is passed into function (see details below). An object having the following fields is passed into overwrite, filter and change function: field - field name value - field value from the source object targetValue - field value from the target object target - reference to the target object source - reference to the source object Default values of settings can be redefined by setSettings method. copy, except and filter settings can be used together. In such situation a field will be copied only when the field satisfies to all settings (i.e. belongs to copied elements, not in exceptions and conforms to filter). Source: index.js, line 313 Returns: Modified target object. Type Object Methods &lt;static&gt; assign(destination, source) Copy values of all of the own properties from one or more source objects to the target object (similar to Object.assign). This function is a \"wrap\" for the following code: mixing(destination, Array.prototype.slice.call(arguments, 1), {overwrite: true, ownProperty: true}); Parameters: Name Type Argument Description destination Object | function The target object into which fields and functions will be copied. source Object &lt;repeatable&gt; An object whose contents will be copied. If a source is a falsy value (e.g. null or undefined), the source will be skipped. Source: index.js, line 426 Returns: Modified target object. Type Object &lt;static&gt; change(source, change) Change values of fields of given object. This function is a \"wrap\" for the following code: mixing(source, source, {change: change, overwrite: true, oneSource: true}); Parameters: Name Type Description source Array | Object An array or an object whose fields should be modified. change function | Object A function or an object that specifies the modification. See mixing for details. Source: index.js, line 445 Returns: Modified source object. Type Object &lt;static&gt; clone( [settings]) Make a copy of this object. This function is a \"wrap\" for the following code: var copy = mixing({}, this, settings); It can be transferred to an object to use as a method. Parameters: Name Type Argument Description settings Object &lt;optional&gt; Operation settings. See mixing for details. Source: index.js, line 501 Returns: Newly created object containing contents of this object. Type Object &lt;static&gt; copy(source [, settings]) Make a copy of source object(s). This function is a \"wrap\" for the following code: var copy = mixing({}, source, settings); Parameters: Name Type Argument Description source Array | Object Array of source objects or just one object whose contents will be copied. settings Object &lt;optional&gt; Operation settings. See mixing for details. Source: index.js, line 464 Returns: Newly created object containing contents of source objects. Type Object &lt;static&gt; filter(filter) Filter this object. This function is a \"wrap\" for the following code: var result = mixing({}, this, {filter: filter}); It can be transferred to an object to use as a method. Parameters: Name Type Description filter function | Object Filter function to select fields or object that represents operation settings including filter function. See mixing for details. Source: index.js, line 520 Returns: Newly created object containing fields of this object for which filter function returns true. Type Object &lt;static&gt; getSettings() Return default settings that were set earlier. Source: index.js, line 588 Returns: Default settings that were set earlier or undefined / null if default settings were not set. Type Object | undefined &lt;static&gt; map(change) Copy and change values of fields of this object. This function is a \"wrap\" for the following code: var result = mixing({}, this, {change: change}); It can be transferred to an object to use as a method. Parameters: Name Type Description change function | Object Function to change values of copied fields or object that represents operation settings including change function. See mixing for details. Source: index.js, line 539 Returns: Newly created object containing fields of this object with changed values. Type Object &lt;static&gt; mix(source [, settings]) Copy/add all fields and functions from source objects into this object. As a result this object may be modified. This function is a \"wrap\" for the following code: mixing(this, source, settings); It can be transferred to an object to use as a method. Parameters: Name Type Argument Description source Array | Object Array of source objects or just one object whose contents will be copied. settings Object &lt;optional&gt; Operation settings. See mixing for details. Source: index.js, line 560 Returns: Modified this object. Type Object &lt;static&gt; mixToItems(destinationList, source [, settings]) Copy fields from source object(s) into every object item of given array. Parameters: Name Type Argument Description destinationList Array An array whose items should be modified. source Array | Object Array of source objects or just one object whose contents will be copied. settings Object &lt;optional&gt; Operation settings that will be applied to every copying. See mixing for details. Source: index.js, line 480 Returns: Original destinationList with possibly modified object items. Type Array &lt;static&gt; setSettings( [settings]) Set (redefine, reset) default settings that should be used for subsequent mixing calls. Parameters: Name Type Argument Description settings Object | undefined &lt;optional&gt; Default settings that should be used for subsequent mixing calls. Initial default values will be used for settings that are not specified in the passed object. Pass undefined, null, non-object or to call without parameter to reset default settings to initial values. Source: index.js, line 602 &lt;static&gt; update(change) Change values of fields of this object. This function is a \"wrap\" for the following code: mixing.change(this, change); It can be transferred to an object to use as a method. Parameters: Name Type Description change function | Object A function or an object that specifies the modification. See mixing for details. Source: index.js, line 578 Returns: Modified this object. Type Object × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
