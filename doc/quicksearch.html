<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" mixing Modules mixing Source: index.js /** * @module mixing */ /*jshint latedef:nofunc*/ var defaultSettings; if (! Array.isArray) { Array.isArray = function(obj) { return Object.prototype.toString.call(obj) === \"[object Array]\"; }; } function prepareFieldList(fieldList, value) { var map, nI, regexp, sType; if (Array.isArray(fieldList)) { if (fieldList.length &gt; 0) { map = {}; nI = fieldList.length; do { map[ fieldList[--nI] ] = value || null; } while(nI); } } else { sType = typeof fieldList; if (sType === \"string\" || sType === \"symbol\") { map = {}; map[fieldList] = value || null; } else if (sType === \"object\") { if (fieldList instanceof RegExp) { regexp = fieldList; } else { map = fieldList; } } } return {map: map, regexp: regexp}; } function copy(destination, source, propName, settings) { /*jshint laxbreak:true*/ var propValue = source[propName], sPropString = propName.toString(), bFuncProp, change, otherNameMap, sType, value; if ((! settings.ownProperty || source.hasOwnProperty(propName)) &amp;&amp; (! settings.copyMap || (propName in settings.copyMap)) &amp;&amp; (! settings.copyRegExp || settings.copyRegExp.test(sPropString)) &amp;&amp; (! settings.exceptions || ! settings.exceptions[propName]) &amp;&amp; (! settings.exceptRegExp || ! settings.exceptRegExp.test(sPropString)) &amp;&amp; (! settings.filter || settings.filter.call(null, {field: propName, value: propValue, target: destination, source: source})) /* jshint -W122 */ &amp;&amp; (! settings.filterRegExp || settings.filterRegExp.test(typeof propValue === \"symbol\" ? propValue.toString() : propValue))) { /* jshint +W122 */ otherNameMap = settings.otherNameMap; if (otherNameMap &amp;&amp; (propName in otherNameMap)) { propName = otherNameMap[propName]; } sType = typeof propValue; // If recursive mode and field's value is an object if (settings.recursive &amp;&amp; propValue &amp;&amp; sType === \"object\" &amp;&amp; (value = destination[propName]) &amp;&amp; typeof value === \"object\" &amp;&amp; (! Array.isArray(propValue) || settings.mixFromArray) &amp;&amp; (! Array.isArray(value) || settings.mixToArray)) { mixing(value, propValue, settings.mixFromArray ? mixing({oneSource: true}, settings) : settings); } else { bFuncProp = (sType === \"function\"); if ((settings.overwrite || ! (propName in destination)) &amp;&amp; (! bFuncProp || settings.copyFunc)) { if (settings.changeFunc) { propValue = settings.changeFunc.call(null, {field: propName, value: propValue, target: destination, source: source}); } else if ((change = settings.change) &amp;&amp; (propName in change)) { propValue = change[propName]; } if (bFuncProp &amp;&amp; settings.funcToProto) { destination.constructor.prototype[propName] = propValue; } else { destination[propName] = propValue; } } } } } /** * Copy/add all fields and functions from source objects into the target object. * As a result the target object may be modified. * * @param {Object | Function} destination * The target object into which fields and functions will be copied. * @param {Array | Object} source * Array of source objects or just one object whose contents will be copied. * If a source is a falsy value (e.g. &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;), the source will be skipped. * @param {Object} [settings] * Operation settings. Fields are names of settings, their values are the corresponding values of settings. * The following settings are being supported. * &lt;table&gt; * &lt;tr&gt; * &lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Default value&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;copyFunc&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Should functions be copied?&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;funcToProto&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; * &lt;td&gt; * Should functions be copied into &lt;code&gt;prototype&lt;/code&gt; of the target object's &lt;code&gt;constructor&lt;/code&gt; * (i.e. into &lt;code&gt;destination.constructor.prototype&lt;/code&gt;)? * &lt;br&gt; * If &lt;code&gt;false&lt;/code&gt; then functions will be copied directly into the target object. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;processSymbol&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Should symbol property keys (i.e. fields whose name is a symbol) be processed?&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;overwrite&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Should a field/function be overwritten when it exists in the target object?&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;recursive&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; * &lt;td&gt; * Should this function be called recursively when field's value of the target and source object is an object? * &lt;br&gt; * If &lt;code&gt;true&lt;/code&gt; then object fields from the target and source objects will be mixed by using this function * with the same settings. * &lt;br&gt; * This option has no dependency with &lt;code&gt;overwrite&lt;/code&gt; setting and has priority over it. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;mixFromArray&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; * &lt;td&gt; * Should contents of a field of the source object be copied when the field's value is an array? * &lt;br&gt; * Will be used only when &lt;code&gt;recursive&lt;/code&gt; setting has &lt;code&gt;true&lt;/code&gt; value. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;mixToArray&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; * &lt;td&gt; * Should contents of a field of the source object be copied into a field of the target object * when the latest field's value is an array? * &lt;br&gt; * Will be used only when &lt;code&gt;recursive&lt;/code&gt; setting has &lt;code&gt;true&lt;/code&gt; value. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;oneSource&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; * &lt;td&gt; * Indicates that array that is passed as &lt;code&gt;source&lt;/code&gt; parameter should be interpreted * directly as copied object instead of list of source objects. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;ownProperty&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;Should only own properties of the source object be copied in the target object?&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Array | Object | RegExp | String | Symbol&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;\"\"&lt;/code&gt; (empty string)&lt;/td&gt; * &lt;td&gt; * Array, object, regular expression or string/symbol that defines names of fields/functions that should be copied. * &lt;br&gt; * If an object is passed then his fields determine copied elements. * If a regular expression is passed, then field names matching the regular expression will be copied. * If a string/symbol is passed then it is name of the only copied field. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;except&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Array | Object | RegExp | String | Symbol&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;\"\"&lt;/code&gt; (empty string)&lt;/td&gt; * &lt;td&gt; * Array, object, regular expression or string/symbol that defines names of fields/functions that shouldn't be copied. * &lt;br&gt; * If an object is passed then his fields with true values determine non-copied elements. * If a regular expression is passed, then field names matching the regular expression will not be copied. * If a string/symbol is passed then it is name of the only non-copied field. * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Function | RegExp&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt; * &lt;td&gt; * Function or regular expression that can be used to select elements that should be copied. * &lt;br&gt; * If regular expression is passed, only those fields will be copied whose values are matching regular expression. * &lt;br&gt; * If specified function returns &lt;code&gt;true&lt;/code&gt; for a field, * the field will be copied in the target object. * &lt;br&gt; * An object having the following fields is passed into filter function: * &lt;ul&gt; * &lt;li&gt;&lt;code&gt;field&lt;/code&gt; - field name * &lt;li&gt;&lt;code&gt;value&lt;/code&gt; - field value * &lt;li&gt;&lt;code&gt;target&lt;/code&gt; - reference to the target object * &lt;li&gt;&lt;code&gt;source&lt;/code&gt; - reference to the source object * &lt;/ul&gt; * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;otherName&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt; * &lt;td&gt; * Defines \"renaming table\" for copied elements. * &lt;br&gt; * Fields of the table are names from a source object, values are the corresponding names in the target object. * &lt;br&gt; * For example, the call * &lt;br&gt; * &lt;code&gt; * mixing({}, {field: 1, func: \"no-func\"}, {otherName: {\"field\": \"prop\", \"func\": \"method\"}}) * &lt;/code&gt; * &lt;br&gt; * will return the following object * &lt;br&gt; * &lt;code&gt;{prop: 1, method: \"no-func\"}&lt;/code&gt; * &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;&lt;code&gt;change&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;Function | Object&lt;/code&gt;&lt;/td&gt; * &lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt; * &lt;td&gt; * Function or object that gives ability to change values that should be copied. * &lt;br&gt; * If an object is passed then his fields determine new values for copied elements. * &lt;br&gt; * If a function is passed then value returned by the function for a field will be copied into the target object * instead of original field's value. * &lt;br&gt; * An object having the following fields is passed into change function: * &lt;ul&gt; * &lt;li&gt;&lt;code&gt;field&lt;/code&gt; - field name * &lt;li&gt;&lt;code&gt;value&lt;/code&gt; - field value * &lt;li&gt;&lt;code&gt;target&lt;/code&gt; - reference to the target object * &lt;li&gt;&lt;code&gt;source&lt;/code&gt; - reference to the source object * &lt;/ul&gt; * &lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; * Default values of settings can be redefined by {@link module:mixing.setSettings setSettings} method. * &lt;br&gt; * &lt;code&gt;copy&lt;/code&gt;, &lt;code&gt;except&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; settings can be used together. * In such situation a field will be copied only when the field satisfies to all settings * (i.e. belongs to copied elements, not in exceptions and conforms to filter). * @return {Object} * Modified target object. * @alias module:mixing */ function mixing(destination, source, settings) { /*jshint boss:true, laxbreak:true*/ var destinationType = typeof destination; var sourceType = typeof source; if (destination &amp;&amp; (destinationType === \"object\" || destinationType === \"function\") &amp;&amp; source &amp;&amp; (sourceType === \"object\" || sourceType === \"function\")) { var obj; // Prepare parameters if (typeof settings !== \"object\" || settings === null) { settings = defaultSettings || {}; } else if (defaultSettings) { obj = defaultSettings; defaultSettings = null; settings = mixing({}, [settings, obj]); defaultSettings = obj; } if (! Array.isArray(source) || settings.oneSource) { source = [source]; } // Prepare settings var getOwnPropertySymbols = Object.getOwnPropertySymbols, getPrototypeOf = Object.getPrototypeOf, options = { copyFunc: (\"copyFunc\" in settings ? settings.copyFunc : true), funcToProto: Boolean(settings.funcToProto), processSymbol: (\"processSymbol\" in settings ? settings.processSymbol : true) &amp;&amp; typeof getOwnPropertySymbols === \"function\", mixFromArray: Boolean(settings.mixFromArray), mixToArray: Boolean(settings.mixToArray), overwrite: Boolean(settings.overwrite), ownProperty: Boolean(settings.ownProperty), recursive: Boolean(settings.recursive), otherNameMap: (\"otherName\" in settings ? settings.otherName : null), changeFunc: settings.changeFunc, copyMap: settings.copyMap, copyRegExp: settings.copyRegExp, exceptions: settings.exceptions, exceptRegExp: settings.exceptRegExp, filterRegExp: settings.filterRegExp }, bOwnProperty = options.ownProperty, bProcessSymbol = options.processSymbol, change = settings.change, copyList = settings.copy, exceptList = settings.except, filter = settings.filter, nI, nK, nL, nQ, propName; if (copyList) { copyList = prepareFieldList(copyList); options.copyMap = copyList.map; options.copyRegExp = copyList.regexp; } if (exceptList) { exceptList = prepareFieldList(exceptList, true); options.exceptions = exceptList.map; options.exceptRegExp = exceptList.regexp; } if (filter) { options[typeof filter === \"object\" ? \"filterRegExp\" : \"filter\"] = filter; } if (change) { options[typeof change === \"function\" ? \"changeFunc\" : \"change\"] = change; } // Copy fields and functions according to settings for (nI = 0, nL = source.length; nI &lt; nL; nI++) { if (obj = source[nI]) { for (propName in obj) { copy(destination, obj, propName, options); } // Process symbol property keys if (bProcessSymbol) { exceptList = {}; do { copyList = getOwnPropertySymbols(obj); for (nK = 0, nQ = copyList.length; nK &lt; nQ; nK++) { propName = copyList[nK]; if (! (propName in exceptList)) { copy(destination, obj, propName, options); exceptList[propName] = true; } } obj = bOwnProperty ? null : getPrototypeOf(obj); } while (obj); } } } } return destination; } /** * Copy values of all of the own properties from one or more source objects to the target object * (similar to &lt;code&gt;Object.assign&lt;/code&gt;). * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * mixing(destination, Array.prototype.slice.call(arguments, 1), {overwrite: true, ownProperty: true}); * &lt;/pre&gt;&lt;/code&gt; * * @param {Object | Function} destination * The target object into which fields and functions will be copied. * @param {...Object} source * An object whose contents will be copied. * If a source is a falsy value (e.g. &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;), the source will be skipped. * @return {Object} * Modified &lt;code&gt;target&lt;/code&gt; object. */ mixing.assign = function(destination) { return mixing(destination, Array.prototype.slice.call(arguments, 1), {overwrite: true, ownProperty: true}); }; /** * Change values of fields of given object. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * mixing(source, source, {change: change, overwrite: true, oneSource: true}); * &lt;/pre&gt;&lt;/code&gt; * * @param {Array | Object} source * An array or an object whose fields should be modified. * @param {Function | Object} change * A function or an object that specifies the modification. See {@link module:mixing mixing} for details. * @return {Object} * Modified &lt;code&gt;source&lt;/code&gt; object. */ mixing.change = function(source, change) { return mixing(source, source, {change: change, overwrite: true, oneSource: true}); }; /** * Make a copy of source object(s). * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * var copy = mixing({}, source, settings); * &lt;/pre&gt;&lt;/code&gt; * * @param {Array | Object} source * Array of source objects or just one object whose contents will be copied. * @param {Object} [settings] * Operation settings. See {@link module:mixing mixing} for details. * @return {Object} * Newly created object containing contents of source objects. */ mixing.copy = function(source, settings) { return mixing({}, source, settings); }; /** * Copy fields from source object(s) into every object item of given array. * * @param {Array} destinationList * An array whose items should be modified. * @param {Array | Object} source * Array of source objects or just one object whose contents will be copied. * @param {Object} [settings] * Operation settings that will be applied to every copying. See {@link module:mixing mixing} for details. * @return {Array} * Original &lt;code&gt;destinationList&lt;/code&gt; with possibly modified object items. */ mixing.mixToItems = function(destinationList, source, settings) { for (var nI = 0, nL = destinationList.length; nI &lt; nL; nI++) { destinationList[nI] = mixing(destinationList[nI], source, settings); } return destinationList; }; /** * Make a copy of &lt;code&gt;this&lt;/code&gt; object. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * var copy = mixing({}, this, settings); * &lt;/pre&gt;&lt;/code&gt; * It can be transferred to an object to use as a method. * * @param {Object} [settings] * Operation settings. See {@link module:mixing mixing} for details. * @return {Object} * Newly created object containing contents of &lt;code&gt;this&lt;/code&gt; object. */ mixing.clone = function(settings) { return mixing({}, this, settings); }; /** * Filter &lt;code&gt;this&lt;/code&gt; object. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * var result = mixing({}, this, {filter: filter}); * &lt;/pre&gt;&lt;/code&gt; * It can be transferred to an object to use as a method. * * @param {Function | Object} filter * Filter function to select fields or object that represents operation settings including filter function. * See {@link module:mixing mixing} for details. * @return {Object} * Newly created object containing fields of &lt;code&gt;this&lt;/code&gt; object for which filter function returns true. */ mixing.filter = function(filter) { return mixing({}, this, typeof filter === \"function\" ? {filter: filter} : filter); }; /** * Copy and change values of fields of &lt;code&gt;this&lt;/code&gt; object. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * var result = mixing({}, this, {change: change}); * &lt;/pre&gt;&lt;/code&gt; * It can be transferred to an object to use as a method. * * @param {Function | Object} change * Function to change values of copied fields or object that represents operation settings including change function. * See {@link module:mixing mixing} for details. * @return {Object} * Newly created object containing fields of &lt;code&gt;this&lt;/code&gt; object with changed values. */ mixing.map = function(change) { return mixing({}, this, typeof change === \"function\" ? {change: change} : change); }; /** * Copy/add all fields and functions from source objects into &lt;code&gt;this&lt;/code&gt; object. * As a result &lt;code&gt;this&lt;/code&gt; object may be modified. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * mixing(this, source, settings); * &lt;/pre&gt;&lt;/code&gt; * It can be transferred to an object to use as a method. * * @param {Array | Object} source * Array of source objects or just one object whose contents will be copied. * @param {Object} [settings] * Operation settings. See {@link module:mixing mixing} for details. * @return {Object} * Modified &lt;code&gt;this&lt;/code&gt; object. */ mixing.mix = function(source, settings) { return mixing(this, source, settings); }; /** * Change values of fields of &lt;code&gt;this&lt;/code&gt; object. * &lt;br&gt; * This function is a \"wrap\" for the following code: * &lt;code&gt;&lt;pre&gt; * mixing.change(this, change); * &lt;/pre&gt;&lt;/code&gt; * It can be transferred to an object to use as a method. * * @param {Function | Object} change * A function or an object that specifies the modification. See {@link module:mixing mixing} for details. * @return {Object} * Modified &lt;code&gt;this&lt;/code&gt; object. */ mixing.update = function(change) { return mixing.change(this, change); }; /** * Return default settings that were set earlier. * * @return {Object | undefined} * Default settings that were set earlier or &lt;code&gt;undefined / null&lt;/code&gt; if default settings were not set. */ mixing.getSettings = function() { return defaultSettings; }; /** * Set (redefine, reset) default settings that should be used for subsequent {@link module:mixing mixing} calls. * * @param {Object | undefined} [settings] * Default settings that should be used for subsequent {@link module:mixing mixing} calls. * Initial default values will be used for settings that are not specified in the passed object. * Pass &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, non-object or to call without parameter * to reset default settings to initial values. * @alias module:mixing.setSettings */ mixing.setSettings = function(settings) { defaultSettings = typeof settings === \"object\" ? settings : null; }; module.exports = mixing; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" mixing Modules mixing Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" mixing Modules mixing × Search results Close "},"module-mixing.html":{"id":"module-mixing.html","title":"Module: mixing","body":" mixing Modules mixing Module: mixing (require(\"mixing\"))(destination, source [, settings]) Copy/add all fields and functions from source objects into the target object. As a result the target object may be modified. Parameters: Name Type Argument Description destination Object | function The target object into which fields and functions will be copied. source Array | Object Array of source objects or just one object whose contents will be copied. If a source is a falsy value (e.g. null or undefined), the source will be skipped. settings Object &lt;optional&gt; Operation settings. Fields are names of settings, their values are the corresponding values of settings. The following settings are being supported. NameTypeDefault valueDescription copyFunc Boolean true Should functions be copied? funcToProto Boolean false Should functions be copied into prototype of the target object's constructor (i.e. into destination.constructor.prototype)? If false then functions will be copied directly into the target object. processSymbol Boolean true Should symbol property keys (i.e. fields whose name is a symbol) be processed? overwrite Boolean false Should a field/function be overwritten when it exists in the target object? recursive Boolean false Should this function be called recursively when field's value of the target and source object is an object? If true then object fields from the target and source objects will be mixed by using this function with the same settings. This option has no dependency with overwrite setting and has priority over it. mixFromArray Boolean false Should contents of a field of the source object be copied when the field's value is an array? Will be used only when recursive setting has true value. mixToArray Boolean false Should contents of a field of the source object be copied into a field of the target object when the latest field's value is an array? Will be used only when recursive setting has true value. oneSource Boolean false Indicates that array that is passed as source parameter should be interpreted directly as copied object instead of list of source objects. ownProperty Boolean false Should only own properties of the source object be copied in the target object? copy Array | Object | RegExp | String | Symbol \"\" (empty string) Array, object, regular expression or string/symbol that defines names of fields/functions that should be copied. If an object is passed then his fields determine copied elements. If a regular expression is passed, then field names matching the regular expression will be copied. If a string/symbol is passed then it is name of the only copied field. except Array | Object | RegExp | String | Symbol \"\" (empty string) Array, object, regular expression or string/symbol that defines names of fields/functions that shouldn't be copied. If an object is passed then his fields with true values determine non-copied elements. If a regular expression is passed, then field names matching the regular expression will not be copied. If a string/symbol is passed then it is name of the only non-copied field. filter Function | RegExp null Function or regular expression that can be used to select elements that should be copied. If regular expression is passed, only those fields will be copied whose values are matching regular expression. If specified function returns true for a field, the field will be copied in the target object. An object having the following fields is passed into filter function: field - field name value - field value target - reference to the target object source - reference to the source object otherName Object null Defines \"renaming table\" for copied elements. Fields of the table are names from a source object, values are the corresponding names in the target object. For example, the call mixing({}, {field: 1, func: \"no-func\"}, {otherName: {\"field\": \"prop\", \"func\": \"method\"}}) will return the following object {prop: 1, method: \"no-func\"} change Function | Object null Function or object that gives ability to change values that should be copied. If an object is passed then his fields determine new values for copied elements. If a function is passed then value returned by the function for a field will be copied into the target object instead of original field's value. An object having the following fields is passed into change function: field - field name value - field value target - reference to the target object source - reference to the source object Default values of settings can be redefined by setSettings method. copy, except and filter settings can be used together. In such situation a field will be copied only when the field satisfies to all settings (i.e. belongs to copied elements, not in exceptions and conforms to filter). Source: index.js, line 282 Returns: Modified target object. Type Object Methods &lt;static&gt; assign(destination, source) Copy values of all of the own properties from one or more source objects to the target object (similar to Object.assign). This function is a \"wrap\" for the following code: mixing(destination, Array.prototype.slice.call(arguments, 1), {overwrite: true, ownProperty: true}); Parameters: Name Type Argument Description destination Object | function The target object into which fields and functions will be copied. source Object &lt;repeatable&gt; An object whose contents will be copied. If a source is a falsy value (e.g. null or undefined), the source will be skipped. Source: index.js, line 395 Returns: Modified target object. Type Object &lt;static&gt; change(source, change) Change values of fields of given object. This function is a \"wrap\" for the following code: mixing(source, source, {change: change, overwrite: true, oneSource: true}); Parameters: Name Type Description source Array | Object An array or an object whose fields should be modified. change function | Object A function or an object that specifies the modification. See mixing for details. Source: index.js, line 414 Returns: Modified source object. Type Object &lt;static&gt; clone( [settings]) Make a copy of this object. This function is a \"wrap\" for the following code: var copy = mixing({}, this, settings); It can be transferred to an object to use as a method. Parameters: Name Type Argument Description settings Object &lt;optional&gt; Operation settings. See mixing for details. Source: index.js, line 470 Returns: Newly created object containing contents of this object. Type Object &lt;static&gt; copy(source [, settings]) Make a copy of source object(s). This function is a \"wrap\" for the following code: var copy = mixing({}, source, settings); Parameters: Name Type Argument Description source Array | Object Array of source objects or just one object whose contents will be copied. settings Object &lt;optional&gt; Operation settings. See mixing for details. Source: index.js, line 433 Returns: Newly created object containing contents of source objects. Type Object &lt;static&gt; filter(filter) Filter this object. This function is a \"wrap\" for the following code: var result = mixing({}, this, {filter: filter}); It can be transferred to an object to use as a method. Parameters: Name Type Description filter function | Object Filter function to select fields or object that represents operation settings including filter function. See mixing for details. Source: index.js, line 489 Returns: Newly created object containing fields of this object for which filter function returns true. Type Object &lt;static&gt; getSettings() Return default settings that were set earlier. Source: index.js, line 557 Returns: Default settings that were set earlier or undefined / null if default settings were not set. Type Object | undefined &lt;static&gt; map(change) Copy and change values of fields of this object. This function is a \"wrap\" for the following code: var result = mixing({}, this, {change: change}); It can be transferred to an object to use as a method. Parameters: Name Type Description change function | Object Function to change values of copied fields or object that represents operation settings including change function. See mixing for details. Source: index.js, line 508 Returns: Newly created object containing fields of this object with changed values. Type Object &lt;static&gt; mix(source [, settings]) Copy/add all fields and functions from source objects into this object. As a result this object may be modified. This function is a \"wrap\" for the following code: mixing(this, source, settings); It can be transferred to an object to use as a method. Parameters: Name Type Argument Description source Array | Object Array of source objects or just one object whose contents will be copied. settings Object &lt;optional&gt; Operation settings. See mixing for details. Source: index.js, line 529 Returns: Modified this object. Type Object &lt;static&gt; mixToItems(destinationList, source [, settings]) Copy fields from source object(s) into every object item of given array. Parameters: Name Type Argument Description destinationList Array An array whose items should be modified. source Array | Object Array of source objects or just one object whose contents will be copied. settings Object &lt;optional&gt; Operation settings that will be applied to every copying. See mixing for details. Source: index.js, line 449 Returns: Original destinationList with possibly modified object items. Type Array &lt;static&gt; setSettings( [settings]) Set (redefine, reset) default settings that should be used for subsequent mixing calls. Parameters: Name Type Argument Description settings Object | undefined &lt;optional&gt; Default settings that should be used for subsequent mixing calls. Initial default values will be used for settings that are not specified in the passed object. Pass undefined, null, non-object or to call without parameter to reset default settings to initial values. Source: index.js, line 571 &lt;static&gt; update(change) Change values of fields of this object. This function is a \"wrap\" for the following code: mixing.change(this, change); It can be transferred to an object to use as a method. Parameters: Name Type Description change function | Object A function or an object that specifies the modification. See mixing for details. Source: index.js, line 547 Returns: Modified this object. Type Object × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
